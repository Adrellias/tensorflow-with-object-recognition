# Make any security camera smarter for less than $50 using Tensorflow

Background to this story. I bought recently a Xiaomi security camera from GearBest(https://www.gearbest.com/ip-cameras/pp_615275.html?wid=1433363).
On its own this camera is already quite good. It has 1080p resolution and comes with the MiHome app. You can configure the camera using a schedule and when it detects movement it will send you a notification to your mobile. But here lies the problem. The camera sends you quite a few alerts and only a small percentage will be because a person was detected. Many times, just noise(such as train), or even a Housefly will trigger the camera. This is not necessarily a bad thing, especially if triggered by sound, as it can be used for a variety of scenarios in the future. But to be useful in terms of security it needs to only trigger alerts for scenarios which are of real concern. Too many false positives and you end up ignoring the warnings. And if you end up ignoring your security alerts, they become useless.

The Mihome camera doesn't come with real "cloud storage". But if you add a memory card the camera has an option to save all its videos in a NAS storage location. Videos files are generated any time movement is detected. And that is exactly what you need.

The goal of this project is to create an application that processes all the videos generated by my Xiaomi security camera and do a visual inspection of each to ensure that only videos where a person is detected will trigger a notification. When you receive this notification, you would be able to see a screenshot of what triggered the camera with a bounding box and also the original video for closer inspection.

## Sources I have used

To be able to build something like a smart camera, you need to stand on the shoulder of giants.
First port of call for me was 

### Youtube with its many videos teaching tensorflow and openCV.

I followed this series:

Tensorflow Object Detection API Tutorial Part 1 - https://www.youtube.com/watch?v=COlbP62-B-U&t=121s

and 

Train an Image Classifier in 3 Minutes - https://www.youtube.com/watch?v=qbFF1r4NGmA&t=14s

### Tensorflow Object Detection API

https://github.com/tensorflow/models/tree/master/research/object_detection

###  Train an Image Classifier in 3 Minutes - Tutorial

https://askmacgyver.com/blog/tutorial/create-image-classifier

This tutorial, alongside the youtube video, helped me getting introduced to image classification with Tensorflow and I used the tensorflow docker instance created by Macgyver as my starting point.
 
https://askmacgyver.com/blog/tutorial/create-image-classifier

## Tools for this project

### Tensorflow

Tensorflow is incredibly powerful and comes with pre-built models that are quite capable to detect something as simple as a person. In fact it can do a lot more than that. The code written uses Tensorflow Object Detection API, which is still in ongoing development.
https://github.com/tensorflow/models/tree/master/research/object_detection. As a starting point I used the object detection tutorial python script. 

### OpenCV

Second tool used is OpenCV.
OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV Is used to process each frame of the video and apply a Tensorflow model.

### Docker

Used to create a container that runs the code for use in any machine that runs docker.

### Slack

Slack is a messaging system used by software development teams around the world. It is used to deliver notifications to your mobile without having to write a mobile app.

### Python

AI's language of choice is Python, and Tensorflow was written in Python. No surprise why we need it.

### STEP 1 - BUY VIDEO SECURITY CAMERA and MEMORY STICK

1. Buy a video security camera such as the Xiaomi Mijia Camera. There are many types of security cameras out there. The setup instructions I am providing here only work for Xiaomi Mijia camera, as that is the one that I purchased. In theory you can buy any camera and as long as you get the camera to save the videos into a NAS storage, that's ok.
The camera doesn't come with a memory stick. In order for the NAS share feature to work you need a memory stick. In this case I recommend 16gb size.

### STEP 2 - CONFIGURE XIAOMI MIJIA CAMERA

Download the MiHome app and setup the camera per instructions. Plenty of Youtube videos that help you on this. Here is one: https://www.youtube.com/watch?v=QXDv1RsccSs
You need to create a NAS share somewhere in your network, to which the camera can upload any videos once motion is detected.
In my home I setup a SMB share on a Raspberry Pi.

### STEP 3 - RUN DOCKER CONTAINER

Once you have the Xiaomi Mijia Camera installed and configured to dump all the videos into a NAS share, you are ready to start the process of setting up the docker container. But you need to install docker first. Don't know docker? Read this: https://docs.docker.com/get-started/

1. Build docker container

``` bash
docker build -t armindocachada/tensorflow-with-object-recognition .
```

2. Start docker container

Pass the -v to share the folder with the docker container in which the camera's surveillance files will be available. You need read/write access to the folder.

Pass the -p to expose the port to access the jupyter notebook

``` bash
docker run -i -t -d -p 8888:8888 -v <NAS FOLDER WITH VIDEOS>:/data/videos/incoming armindocachada/tensorflow-with-object-recognition /bin/bash

```

### STEP 4 - Delivering the notifications

Instead of relying on the Mihome app for receiving notifications it was decided to deliver notification straight to Slack under a specific channel.

To try this demo, you need to create a Slack account and a private channel and generate a security token. Then you need to save this security token into config.ini using the config.ini.template file. Don't forget to rename it to config.ini, and paste the channel id.


``` bash
[Slack]
secretToken: a secret token
channelId: a channel id
```

### STEP 5 - Understanding Tensorflow customisations ###

To better understand the customisations made to the tensorflow object detection demo, lets open a jupyter notebook:

docker exec -it <CONTAINER ID> /bin/bash -c "export COLUMNS=tput cols; export LINES=tput lines; exec bash"

``` bash
cd /tensorflow/models/research/object_detection
jupyter notebook --allow-root


[W 10:01:22.633 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.
[I 10:01:22.641 NotebookApp] Serving notebooks from local directory: /tensorflow/models/research/object_detection
[I 10:01:22.641 NotebookApp] 0 active kernels
[I 10:01:22.641 NotebookApp] The Jupyter Notebook is running at:
[I 10:01:22.641 NotebookApp] http://[all ip addresses on your system]:8888/?token=633828212cbfe0d0a7a6675beeaf4e8cfa3670bcfc692cf2
[I 10:01:22.641 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
[C 10:01:22.642 NotebookApp] 
    
    Copy/paste this URL into your browser when you connect for the first time,
    to login with a token:
        http://localhost:8888/?token=633828212cbfe0d0a7a6675beeaf4e8cfa3670bcfc692cf2
```

Copy the url given by the newly started notebook server and open it in a browser.

Methods to look for:


Whenever a person is detected in a video uploaded by the security camera, a method called notifySlack is called.
This method uses the slack API to upload the video and an image to allow for quick identification of the security threat in the video.
I used slack for speed of development. It comes with built-in security, as I can control the access to the channel to only the people I want to.
It comes with a mobile app for android and ios, therefore I don't have to develop any app to make the notifications work.
This is perfectly acceptable for a proof of concept and maybe some limited use at your home. 

```python
def notifySlack(plt, image_np):
    plt.imsave("/data/plot.png", image_np)
            
    sc.api_call(
      "chat.postMessage",
      channel=channel_id,
      text="Unidentified person detected in file={}".format(file)

    )


    with open('/data/plot.png', 'rb') as f:
        sc.api_call(
            "files.upload",
            channels=channel_id,
            filename='snapshot.png',
            title='Detected Person',
            initial_comment='Detected person by webcam. Is it anyone you know?',
            file=io.BytesIO(f.read())
        )

    with open(file, 'rb') as f:
        sc.api_call(
            "files.upload",
            channels=channel_id,
            filename='$file',
            title='Video with detected person',
            initial_comment='Video with detected person',
            file=io.BytesIO(f.read())
        )
```

The way the object detection works, using the OpenCV library, we take sample video frames from a video file (not every single video frame because the video files have 20 frames per second!), and for each frame captured we call the run_inference_for_single_image(image_np, detection_graph) method. This method returns a dictionary with the results of the inference analysis. 

```python


def processVideoFile(file):
     cap = cv2.VideoCapture(file)
     totalFrameCount = cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT)
    
     if totalFrameCount == 0:
            print "Video file={} not yet ready for processing. Skipping.".format(file)
            return False
        
     print "Processing video file with {} frames".format( totalFrameCount)
     
     while True:
        ret, image_np = cap.read()
        currentFrame = cap.get(cv2.cv.CV_CAP_PROP_POS_FRAMES)
        print "Processing frame {} of {} for video file={}".format(currentFrame,totalFrameCount, file) 
        if not ret:
            break
       
      ...
            
        # skips frames as the rate of the camera is 20 fps
        nextFrame = min(currentFrame + FRAMES_TO_SKIP, totalFrameCount)
        cap.set(cv2.cv.CV_CAP_PROP_POS_FRAMES, nextFrame)  
     return True
     
```

We use the SSD Inception v2 pre-trained model( ssd_inception_v2_coco_2017_11_17), which already contains common objection detection classes, including **person** which is the only object detection class we are interested in this case. But its so easy to change it. 

Lets say you are trying to create a smart wildlife camera and you want to detect animals such as a very rare **Lion**. You can modify the method below to only search for **Lions**. In order to reduce false positives, you can also increase the score from the default value of 0.5 to something higher if wished. From personal experimentation 0.5 worked well for me.

```python
def detectPerson(output_dict, category_index):
    result = False
    classes = output_dict['detection_classes']  
    for i in range(len(classes)):
        score = output_dict['detection_scores'][i]
        label = category_index.get(classes[i])
        if (score>0.5 and label['name'] == 'person' ):
            result = True
            break
            
    return result
```

![How a notification looks on slack](/assets/slack_screenshot_part1.png")
![How a notification looks on slack](/assets/slack_screenshot_part2.png")

